-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.Mutation exposing (..)

import Api.InputObject
import Api.Interface
import Api.Object
import Api.Scalar
import Api.ScalarCodecs
import Api.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias DeleteGamesRequiredArguments =
    { where_ : Api.InputObject.Games_bool_exp }


{-| delete data from the table: "games"

  - where\_ - filter the rows which have to be deleted

-}
delete_games : DeleteGamesRequiredArguments -> SelectionSet decodesTo Api.Object.Games_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
delete_games requiredArgs object_ =
    Object.selectionForCompositeField "delete_games" [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodeGames_bool_exp ] object_ (identity >> Decode.nullable)


type alias InsertGamesOptionalArguments =
    { on_conflict : OptionalArgument Api.InputObject.Games_on_conflict }


type alias InsertGamesRequiredArguments =
    { objects : List Api.InputObject.Games_insert_input }


{-| insert data into the table: "games"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_games : (InsertGamesOptionalArguments -> InsertGamesOptionalArguments) -> InsertGamesRequiredArguments -> SelectionSet decodesTo Api.Object.Games_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
insert_games fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Api.InputObject.encodeGames_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_games" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Api.InputObject.encodeGames_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias UpdateGamesOptionalArguments =
    { inc_ : OptionalArgument Api.InputObject.Games_inc_input
    , set_ : OptionalArgument Api.InputObject.Games_set_input
    }


type alias UpdateGamesRequiredArguments =
    { where_ : Api.InputObject.Games_bool_exp }


{-| update data of the table: "games"

  - inc\_ - increments the integer columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_games : (UpdateGamesOptionalArguments -> UpdateGamesOptionalArguments) -> UpdateGamesRequiredArguments -> SelectionSet decodesTo Api.Object.Games_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
update_games fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { inc_ = Absent, set_ = Absent }

        optionalArgs =
            [ Argument.optional "_inc" filledInOptionals.inc_ Api.InputObject.encodeGames_inc_input, Argument.optional "_set" filledInOptionals.set_ Api.InputObject.encodeGames_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_games" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodeGames_bool_exp ]) object_ (identity >> Decode.nullable)
