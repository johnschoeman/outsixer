-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Outsixer.InputObject exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode
import Outsixer.Enum.Game_constraint
import Outsixer.Enum.Game_update_column
import Outsixer.Enum.Order_by
import Outsixer.Interface
import Outsixer.Object
import Outsixer.Scalar
import Outsixer.ScalarCodecs
import Outsixer.Union


buildBoolean_comparison_exp : (Boolean_comparison_expOptionalFields -> Boolean_comparison_expOptionalFields) -> Boolean_comparison_exp
buildBoolean_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Boolean_comparison_expOptionalFields =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Type for the Boolean\_comparison\_exp input object.
-}
type alias Boolean_comparison_exp =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Encode a Boolean\_comparison\_exp into a value that can be used as an argument.
-}
encodeBoolean_comparison_exp : Boolean_comparison_exp -> Value
encodeBoolean_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.bool |> Encode.optional input.eq_ ), ( "_gt", Encode.bool |> Encode.optional input.gt_ ), ( "_gte", Encode.bool |> Encode.optional input.gte_ ), ( "_in", (Encode.bool |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.bool |> Encode.optional input.lt_ ), ( "_lte", Encode.bool |> Encode.optional input.lte_ ), ( "_neq", Encode.bool |> Encode.optional input.neq_ ), ( "_nin", (Encode.bool |> Encode.list) |> Encode.optional input.nin_ ) ]


buildGame_aggregate_order_by : (Game_aggregate_order_byOptionalFields -> Game_aggregate_order_byOptionalFields) -> Game_aggregate_order_by
buildGame_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Game_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Game_avg_order_by
    , count : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , max : OptionalArgument Game_max_order_by
    , min : OptionalArgument Game_min_order_by
    , stddev : OptionalArgument Game_stddev_order_by
    , stddev_pop : OptionalArgument Game_stddev_pop_order_by
    , stddev_samp : OptionalArgument Game_stddev_samp_order_by
    , sum : OptionalArgument Game_sum_order_by
    , var_pop : OptionalArgument Game_var_pop_order_by
    , var_samp : OptionalArgument Game_var_samp_order_by
    , variance : OptionalArgument Game_variance_order_by
    }


{-| Type for the Game\_aggregate\_order\_by input object.
-}
type alias Game_aggregate_order_by =
    { avg : OptionalArgument Game_avg_order_by
    , count : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , max : OptionalArgument Game_max_order_by
    , min : OptionalArgument Game_min_order_by
    , stddev : OptionalArgument Game_stddev_order_by
    , stddev_pop : OptionalArgument Game_stddev_pop_order_by
    , stddev_samp : OptionalArgument Game_stddev_samp_order_by
    , sum : OptionalArgument Game_sum_order_by
    , var_pop : OptionalArgument Game_var_pop_order_by
    , var_samp : OptionalArgument Game_var_samp_order_by
    , variance : OptionalArgument Game_variance_order_by
    }


{-| Encode a Game\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeGame_aggregate_order_by : Game_aggregate_order_by -> Value
encodeGame_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeGame_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeGame_max_order_by |> Encode.optional input.max ), ( "min", encodeGame_min_order_by |> Encode.optional input.min ), ( "stddev", encodeGame_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeGame_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeGame_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeGame_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeGame_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeGame_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeGame_variance_order_by |> Encode.optional input.variance ) ]


buildGame_arr_rel_insert_input : Game_arr_rel_insert_inputRequiredFields -> (Game_arr_rel_insert_inputOptionalFields -> Game_arr_rel_insert_inputOptionalFields) -> Game_arr_rel_insert_input
buildGame_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Game_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Game_arr_rel_insert_inputRequiredFields =
    { data : List Game_insert_input }


type alias Game_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Game_on_conflict }


{-| Type alias for the `Game_arr_rel_insert_input` attributes. Note that this type
needs to use the `Game_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Game_arr_rel_insert_inputRaw =
    { data : List Game_insert_input
    , on_conflict : OptionalArgument Game_on_conflict
    }


{-| Type for the Game\_arr\_rel\_insert\_input input object.
-}
type Game_arr_rel_insert_input
    = Game_arr_rel_insert_input Game_arr_rel_insert_inputRaw


{-| Encode a Game\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeGame_arr_rel_insert_input : Game_arr_rel_insert_input -> Value
encodeGame_arr_rel_insert_input (Game_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeGame_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeGame_on_conflict |> Encode.optional input.on_conflict ) ]


buildGame_avg_order_by : (Game_avg_order_byOptionalFields -> Game_avg_order_byOptionalFields) -> Game_avg_order_by
buildGame_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_avg_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_avg\_order\_by input object.
-}
type alias Game_avg_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_avg\_order\_by into a value that can be used as an argument.
-}
encodeGame_avg_order_by : Game_avg_order_by -> Value
encodeGame_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_bool_exp : (Game_bool_expOptionalFields -> Game_bool_expOptionalFields) -> Game_bool_exp
buildGame_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, active = Absent, created_at = Absent, id = Absent, name = Absent, updated_at = Absent }
    in
    Game_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, active = optionals.active, created_at = optionals.created_at, id = optionals.id, name = optionals.name, updated_at = optionals.updated_at }


type alias Game_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Game_bool_exp))
    , not_ : OptionalArgument Game_bool_exp
    , or_ : OptionalArgument (List (Maybe Game_bool_exp))
    , active : OptionalArgument Boolean_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Game_bool_exp` attributes. Note that this type
needs to use the `Game_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Game_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Game_bool_exp))
    , not_ : OptionalArgument Game_bool_exp
    , or_ : OptionalArgument (List (Maybe Game_bool_exp))
    , active : OptionalArgument Boolean_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Game\_bool\_exp input object.
-}
type Game_bool_exp
    = Game_bool_exp Game_bool_expRaw


{-| Encode a Game\_bool\_exp into a value that can be used as an argument.
-}
encodeGame_bool_exp : Game_bool_exp -> Value
encodeGame_bool_exp (Game_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeGame_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeGame_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeGame_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "active", encodeBoolean_comparison_exp |> Encode.optional input.active ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input.created_at ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "name", encodeString_comparison_exp |> Encode.optional input.name ), ( "updated_at", encodeTimestamptz_comparison_exp |> Encode.optional input.updated_at ) ]


buildGame_inc_input : (Game_inc_inputOptionalFields -> Game_inc_inputOptionalFields) -> Game_inc_input
buildGame_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_inc_inputOptionalFields =
    { id : OptionalArgument Int }


{-| Type for the Game\_inc\_input input object.
-}
type alias Game_inc_input =
    { id : OptionalArgument Int }


{-| Encode a Game\_inc\_input into a value that can be used as an argument.
-}
encodeGame_inc_input : Game_inc_input -> Value
encodeGame_inc_input input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ) ]


buildGame_insert_input : (Game_insert_inputOptionalFields -> Game_insert_inputOptionalFields) -> Game_insert_input
buildGame_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { active = Absent, created_at = Absent, id = Absent, name = Absent, updated_at = Absent }
    in
    { active = optionals.active, created_at = optionals.created_at, id = optionals.id, name = optionals.name, updated_at = optionals.updated_at }


type alias Game_insert_inputOptionalFields =
    { active : OptionalArgument Bool
    , created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    }


{-| Type for the Game\_insert\_input input object.
-}
type alias Game_insert_input =
    { active : OptionalArgument Bool
    , created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    }


{-| Encode a Game\_insert\_input into a value that can be used as an argument.
-}
encodeGame_insert_input : Game_insert_input -> Value
encodeGame_insert_input input =
    Encode.maybeObject
        [ ( "active", Encode.bool |> Encode.optional input.active ), ( "created_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created_at ), ( "id", Encode.int |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "updated_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.updated_at ) ]


buildGame_max_order_by : (Game_max_order_byOptionalFields -> Game_max_order_byOptionalFields) -> Game_max_order_by
buildGame_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, name = Absent, updated_at = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, name = optionals.name, updated_at = optionals.updated_at }


type alias Game_max_order_byOptionalFields =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Game\_max\_order\_by input object.
-}
type alias Game_max_order_by =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Game\_max\_order\_by into a value that can be used as an argument.
-}
encodeGame_max_order_by : Game_max_order_by -> Value
encodeGame_max_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.name ), ( "updated_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.updated_at ) ]


buildGame_min_order_by : (Game_min_order_byOptionalFields -> Game_min_order_byOptionalFields) -> Game_min_order_by
buildGame_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, name = Absent, updated_at = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, name = optionals.name, updated_at = optionals.updated_at }


type alias Game_min_order_byOptionalFields =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Game\_min\_order\_by input object.
-}
type alias Game_min_order_by =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Game\_min\_order\_by into a value that can be used as an argument.
-}
encodeGame_min_order_by : Game_min_order_by -> Value
encodeGame_min_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.name ), ( "updated_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.updated_at ) ]


buildGame_obj_rel_insert_input : Game_obj_rel_insert_inputRequiredFields -> (Game_obj_rel_insert_inputOptionalFields -> Game_obj_rel_insert_inputOptionalFields) -> Game_obj_rel_insert_input
buildGame_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Game_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Game_obj_rel_insert_inputRequiredFields =
    { data : Game_insert_input }


type alias Game_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Game_on_conflict }


{-| Type alias for the `Game_obj_rel_insert_input` attributes. Note that this type
needs to use the `Game_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Game_obj_rel_insert_inputRaw =
    { data : Game_insert_input
    , on_conflict : OptionalArgument Game_on_conflict
    }


{-| Type for the Game\_obj\_rel\_insert\_input input object.
-}
type Game_obj_rel_insert_input
    = Game_obj_rel_insert_input Game_obj_rel_insert_inputRaw


{-| Encode a Game\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeGame_obj_rel_insert_input : Game_obj_rel_insert_input -> Value
encodeGame_obj_rel_insert_input (Game_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeGame_insert_input input.data |> Just ), ( "on_conflict", encodeGame_on_conflict |> Encode.optional input.on_conflict ) ]


buildGame_on_conflict : Game_on_conflictRequiredFields -> (Game_on_conflictOptionalFields -> Game_on_conflictOptionalFields) -> Game_on_conflict
buildGame_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Game_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Game_on_conflictRequiredFields =
    { constraint : Outsixer.Enum.Game_constraint.Game_constraint
    , update_columns : List Outsixer.Enum.Game_update_column.Game_update_column
    }


type alias Game_on_conflictOptionalFields =
    { where_ : OptionalArgument Game_bool_exp }


{-| Type alias for the `Game_on_conflict` attributes. Note that this type
needs to use the `Game_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Game_on_conflictRaw =
    { constraint : Outsixer.Enum.Game_constraint.Game_constraint
    , update_columns : List Outsixer.Enum.Game_update_column.Game_update_column
    , where_ : OptionalArgument Game_bool_exp
    }


{-| Type for the Game\_on\_conflict input object.
-}
type Game_on_conflict
    = Game_on_conflict Game_on_conflictRaw


{-| Encode a Game\_on\_conflict into a value that can be used as an argument.
-}
encodeGame_on_conflict : Game_on_conflict -> Value
encodeGame_on_conflict (Game_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Outsixer.Enum.Game_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Outsixer.Enum.Game_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeGame_bool_exp |> Encode.optional input.where_ ) ]


buildGame_order_by : (Game_order_byOptionalFields -> Game_order_byOptionalFields) -> Game_order_by
buildGame_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { active = Absent, created_at = Absent, id = Absent, name = Absent, updated_at = Absent }
    in
    { active = optionals.active, created_at = optionals.created_at, id = optionals.id, name = optionals.name, updated_at = optionals.updated_at }


type alias Game_order_byOptionalFields =
    { active : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Game\_order\_by input object.
-}
type alias Game_order_by =
    { active : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Game\_order\_by into a value that can be used as an argument.
-}
encodeGame_order_by : Game_order_by -> Value
encodeGame_order_by input =
    Encode.maybeObject
        [ ( "active", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.active ), ( "created_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.name ), ( "updated_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.updated_at ) ]


buildGame_set_input : (Game_set_inputOptionalFields -> Game_set_inputOptionalFields) -> Game_set_input
buildGame_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { active = Absent, created_at = Absent, id = Absent, name = Absent, updated_at = Absent }
    in
    { active = optionals.active, created_at = optionals.created_at, id = optionals.id, name = optionals.name, updated_at = optionals.updated_at }


type alias Game_set_inputOptionalFields =
    { active : OptionalArgument Bool
    , created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    }


{-| Type for the Game\_set\_input input object.
-}
type alias Game_set_input =
    { active : OptionalArgument Bool
    , created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    }


{-| Encode a Game\_set\_input into a value that can be used as an argument.
-}
encodeGame_set_input : Game_set_input -> Value
encodeGame_set_input input =
    Encode.maybeObject
        [ ( "active", Encode.bool |> Encode.optional input.active ), ( "created_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created_at ), ( "id", Encode.int |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "updated_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.updated_at ) ]


buildGame_stddev_order_by : (Game_stddev_order_byOptionalFields -> Game_stddev_order_byOptionalFields) -> Game_stddev_order_by
buildGame_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_stddev_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_stddev\_order\_by input object.
-}
type alias Game_stddev_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeGame_stddev_order_by : Game_stddev_order_by -> Value
encodeGame_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_stddev_pop_order_by : (Game_stddev_pop_order_byOptionalFields -> Game_stddev_pop_order_byOptionalFields) -> Game_stddev_pop_order_by
buildGame_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_stddev\_pop\_order\_by input object.
-}
type alias Game_stddev_pop_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeGame_stddev_pop_order_by : Game_stddev_pop_order_by -> Value
encodeGame_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_stddev_samp_order_by : (Game_stddev_samp_order_byOptionalFields -> Game_stddev_samp_order_byOptionalFields) -> Game_stddev_samp_order_by
buildGame_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_stddev\_samp\_order\_by input object.
-}
type alias Game_stddev_samp_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeGame_stddev_samp_order_by : Game_stddev_samp_order_by -> Value
encodeGame_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_sum_order_by : (Game_sum_order_byOptionalFields -> Game_sum_order_byOptionalFields) -> Game_sum_order_by
buildGame_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_sum_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_sum\_order\_by input object.
-}
type alias Game_sum_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_sum\_order\_by into a value that can be used as an argument.
-}
encodeGame_sum_order_by : Game_sum_order_by -> Value
encodeGame_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_var_pop_order_by : (Game_var_pop_order_byOptionalFields -> Game_var_pop_order_byOptionalFields) -> Game_var_pop_order_by
buildGame_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_var_pop_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_var\_pop\_order\_by input object.
-}
type alias Game_var_pop_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeGame_var_pop_order_by : Game_var_pop_order_by -> Value
encodeGame_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_var_samp_order_by : (Game_var_samp_order_byOptionalFields -> Game_var_samp_order_byOptionalFields) -> Game_var_samp_order_by
buildGame_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_var_samp_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_var\_samp\_order\_by input object.
-}
type alias Game_var_samp_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeGame_var_samp_order_by : Game_var_samp_order_by -> Value
encodeGame_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_variance_order_by : (Game_variance_order_byOptionalFields -> Game_variance_order_byOptionalFields) -> Game_variance_order_by
buildGame_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_variance_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_variance\_order\_by input object.
-}
type alias Game_variance_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_variance\_order\_by into a value that can be used as an argument.
-}
encodeGame_variance_order_by : Game_variance_order_by -> Value
encodeGame_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildInt_comparison_exp : (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields) -> Int_comparison_exp
buildInt_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input.eq_ ), ( "_gt", Encode.int |> Encode.optional input.gt_ ), ( "_gte", Encode.int |> Encode.optional input.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.int |> Encode.optional input.lt_ ), ( "_lte", Encode.int |> Encode.optional input.lte_ ), ( "_neq", Encode.int |> Encode.optional input.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input.nin_ ) ]


buildString_comparison_exp : (String_comparison_expOptionalFields -> String_comparison_expOptionalFields) -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTimestamptz_comparison_exp : (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields) -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Outsixer.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Outsixer.ScalarCodecs.Timestamptz)
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Outsixer.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Outsixer.ScalarCodecs.Timestamptz)
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.eq_ ), ( "_gt", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gt_ ), ( "_gte", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gte_ ), ( "_in", ((Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lt_ ), ( "_lte", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lte_ ), ( "_neq", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.neq_ ), ( "_nin", ((Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.nin_ ) ]
