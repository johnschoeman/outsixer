-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Outsixer.InputObject exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode
import Outsixer.Enum.Game_constraint
import Outsixer.Enum.Game_update_column
import Outsixer.Enum.Order_by
import Outsixer.Enum.Player_constraint
import Outsixer.Enum.Player_update_column
import Outsixer.Interface
import Outsixer.Object
import Outsixer.Scalar
import Outsixer.ScalarCodecs
import Outsixer.Union


buildBoolean_comparison_exp : (Boolean_comparison_expOptionalFields -> Boolean_comparison_expOptionalFields) -> Boolean_comparison_exp
buildBoolean_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Boolean_comparison_expOptionalFields =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Type for the Boolean\_comparison\_exp input object.
-}
type alias Boolean_comparison_exp =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Encode a Boolean\_comparison\_exp into a value that can be used as an argument.
-}
encodeBoolean_comparison_exp : Boolean_comparison_exp -> Value
encodeBoolean_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.bool |> Encode.optional input.eq_ ), ( "_gt", Encode.bool |> Encode.optional input.gt_ ), ( "_gte", Encode.bool |> Encode.optional input.gte_ ), ( "_in", (Encode.bool |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.bool |> Encode.optional input.lt_ ), ( "_lte", Encode.bool |> Encode.optional input.lte_ ), ( "_neq", Encode.bool |> Encode.optional input.neq_ ), ( "_nin", (Encode.bool |> Encode.list) |> Encode.optional input.nin_ ) ]


buildGame_aggregate_order_by : (Game_aggregate_order_byOptionalFields -> Game_aggregate_order_byOptionalFields) -> Game_aggregate_order_by
buildGame_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Game_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Game_avg_order_by
    , count : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , max : OptionalArgument Game_max_order_by
    , min : OptionalArgument Game_min_order_by
    , stddev : OptionalArgument Game_stddev_order_by
    , stddev_pop : OptionalArgument Game_stddev_pop_order_by
    , stddev_samp : OptionalArgument Game_stddev_samp_order_by
    , sum : OptionalArgument Game_sum_order_by
    , var_pop : OptionalArgument Game_var_pop_order_by
    , var_samp : OptionalArgument Game_var_samp_order_by
    , variance : OptionalArgument Game_variance_order_by
    }


{-| Type for the Game\_aggregate\_order\_by input object.
-}
type alias Game_aggregate_order_by =
    { avg : OptionalArgument Game_avg_order_by
    , count : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , max : OptionalArgument Game_max_order_by
    , min : OptionalArgument Game_min_order_by
    , stddev : OptionalArgument Game_stddev_order_by
    , stddev_pop : OptionalArgument Game_stddev_pop_order_by
    , stddev_samp : OptionalArgument Game_stddev_samp_order_by
    , sum : OptionalArgument Game_sum_order_by
    , var_pop : OptionalArgument Game_var_pop_order_by
    , var_samp : OptionalArgument Game_var_samp_order_by
    , variance : OptionalArgument Game_variance_order_by
    }


{-| Encode a Game\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeGame_aggregate_order_by : Game_aggregate_order_by -> Value
encodeGame_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeGame_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeGame_max_order_by |> Encode.optional input.max ), ( "min", encodeGame_min_order_by |> Encode.optional input.min ), ( "stddev", encodeGame_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeGame_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeGame_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeGame_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeGame_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeGame_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeGame_variance_order_by |> Encode.optional input.variance ) ]


buildGame_arr_rel_insert_input : Game_arr_rel_insert_inputRequiredFields -> (Game_arr_rel_insert_inputOptionalFields -> Game_arr_rel_insert_inputOptionalFields) -> Game_arr_rel_insert_input
buildGame_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Game_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Game_arr_rel_insert_inputRequiredFields =
    { data : List Game_insert_input }


type alias Game_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Game_on_conflict }


{-| Type alias for the `Game_arr_rel_insert_input` attributes. Note that this type
needs to use the `Game_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Game_arr_rel_insert_inputRaw =
    { data : List Game_insert_input
    , on_conflict : OptionalArgument Game_on_conflict
    }


{-| Type for the Game\_arr\_rel\_insert\_input input object.
-}
type Game_arr_rel_insert_input
    = Game_arr_rel_insert_input Game_arr_rel_insert_inputRaw


{-| Encode a Game\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeGame_arr_rel_insert_input : Game_arr_rel_insert_input -> Value
encodeGame_arr_rel_insert_input (Game_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeGame_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeGame_on_conflict |> Encode.optional input.on_conflict ) ]


buildGame_avg_order_by : (Game_avg_order_byOptionalFields -> Game_avg_order_byOptionalFields) -> Game_avg_order_by
buildGame_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_avg_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_avg\_order\_by input object.
-}
type alias Game_avg_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_avg\_order\_by into a value that can be used as an argument.
-}
encodeGame_avg_order_by : Game_avg_order_by -> Value
encodeGame_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_bool_exp : (Game_bool_expOptionalFields -> Game_bool_expOptionalFields) -> Game_bool_exp
buildGame_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, active = Absent, created_at = Absent, id = Absent, name = Absent, players = Absent, updated_at = Absent, word = Absent }
    in
    Game_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, active = optionals.active, created_at = optionals.created_at, id = optionals.id, name = optionals.name, players = optionals.players, updated_at = optionals.updated_at, word = optionals.word }


type alias Game_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Game_bool_exp))
    , not_ : OptionalArgument Game_bool_exp
    , or_ : OptionalArgument (List (Maybe Game_bool_exp))
    , active : OptionalArgument Boolean_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , players : OptionalArgument Player_bool_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    , word : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Game_bool_exp` attributes. Note that this type
needs to use the `Game_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Game_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Game_bool_exp))
    , not_ : OptionalArgument Game_bool_exp
    , or_ : OptionalArgument (List (Maybe Game_bool_exp))
    , active : OptionalArgument Boolean_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , players : OptionalArgument Player_bool_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    , word : OptionalArgument String_comparison_exp
    }


{-| Type for the Game\_bool\_exp input object.
-}
type Game_bool_exp
    = Game_bool_exp Game_bool_expRaw


{-| Encode a Game\_bool\_exp into a value that can be used as an argument.
-}
encodeGame_bool_exp : Game_bool_exp -> Value
encodeGame_bool_exp (Game_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeGame_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeGame_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeGame_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "active", encodeBoolean_comparison_exp |> Encode.optional input.active ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input.created_at ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "name", encodeString_comparison_exp |> Encode.optional input.name ), ( "players", encodePlayer_bool_exp |> Encode.optional input.players ), ( "updated_at", encodeTimestamptz_comparison_exp |> Encode.optional input.updated_at ), ( "word", encodeString_comparison_exp |> Encode.optional input.word ) ]


buildGame_inc_input : (Game_inc_inputOptionalFields -> Game_inc_inputOptionalFields) -> Game_inc_input
buildGame_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_inc_inputOptionalFields =
    { id : OptionalArgument Int }


{-| Type for the Game\_inc\_input input object.
-}
type alias Game_inc_input =
    { id : OptionalArgument Int }


{-| Encode a Game\_inc\_input into a value that can be used as an argument.
-}
encodeGame_inc_input : Game_inc_input -> Value
encodeGame_inc_input input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ) ]


buildGame_insert_input : (Game_insert_inputOptionalFields -> Game_insert_inputOptionalFields) -> Game_insert_input
buildGame_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { active = Absent, created_at = Absent, id = Absent, name = Absent, players = Absent, updated_at = Absent, word = Absent }
    in
    Game_insert_input { active = optionals.active, created_at = optionals.created_at, id = optionals.id, name = optionals.name, players = optionals.players, updated_at = optionals.updated_at, word = optionals.word }


type alias Game_insert_inputOptionalFields =
    { active : OptionalArgument Bool
    , created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , players : OptionalArgument Player_arr_rel_insert_input
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , word : OptionalArgument String
    }


{-| Type alias for the `Game_insert_input` attributes. Note that this type
needs to use the `Game_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Game_insert_inputRaw =
    { active : OptionalArgument Bool
    , created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , players : OptionalArgument Player_arr_rel_insert_input
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , word : OptionalArgument String
    }


{-| Type for the Game\_insert\_input input object.
-}
type Game_insert_input
    = Game_insert_input Game_insert_inputRaw


{-| Encode a Game\_insert\_input into a value that can be used as an argument.
-}
encodeGame_insert_input : Game_insert_input -> Value
encodeGame_insert_input (Game_insert_input input) =
    Encode.maybeObject
        [ ( "active", Encode.bool |> Encode.optional input.active ), ( "created_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created_at ), ( "id", Encode.int |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "players", encodePlayer_arr_rel_insert_input |> Encode.optional input.players ), ( "updated_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.updated_at ), ( "word", Encode.string |> Encode.optional input.word ) ]


buildGame_max_order_by : (Game_max_order_byOptionalFields -> Game_max_order_byOptionalFields) -> Game_max_order_by
buildGame_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, name = Absent, updated_at = Absent, word = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, name = optionals.name, updated_at = optionals.updated_at, word = optionals.word }


type alias Game_max_order_byOptionalFields =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , word : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Game\_max\_order\_by input object.
-}
type alias Game_max_order_by =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , word : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Game\_max\_order\_by into a value that can be used as an argument.
-}
encodeGame_max_order_by : Game_max_order_by -> Value
encodeGame_max_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.name ), ( "updated_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.updated_at ), ( "word", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.word ) ]


buildGame_min_order_by : (Game_min_order_byOptionalFields -> Game_min_order_byOptionalFields) -> Game_min_order_by
buildGame_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, name = Absent, updated_at = Absent, word = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, name = optionals.name, updated_at = optionals.updated_at, word = optionals.word }


type alias Game_min_order_byOptionalFields =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , word : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Game\_min\_order\_by input object.
-}
type alias Game_min_order_by =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , word : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Game\_min\_order\_by into a value that can be used as an argument.
-}
encodeGame_min_order_by : Game_min_order_by -> Value
encodeGame_min_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.name ), ( "updated_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.updated_at ), ( "word", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.word ) ]


buildGame_obj_rel_insert_input : Game_obj_rel_insert_inputRequiredFields -> (Game_obj_rel_insert_inputOptionalFields -> Game_obj_rel_insert_inputOptionalFields) -> Game_obj_rel_insert_input
buildGame_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Game_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Game_obj_rel_insert_inputRequiredFields =
    { data : Game_insert_input }


type alias Game_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Game_on_conflict }


{-| Type alias for the `Game_obj_rel_insert_input` attributes. Note that this type
needs to use the `Game_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Game_obj_rel_insert_inputRaw =
    { data : Game_insert_input
    , on_conflict : OptionalArgument Game_on_conflict
    }


{-| Type for the Game\_obj\_rel\_insert\_input input object.
-}
type Game_obj_rel_insert_input
    = Game_obj_rel_insert_input Game_obj_rel_insert_inputRaw


{-| Encode a Game\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeGame_obj_rel_insert_input : Game_obj_rel_insert_input -> Value
encodeGame_obj_rel_insert_input (Game_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeGame_insert_input input.data |> Just ), ( "on_conflict", encodeGame_on_conflict |> Encode.optional input.on_conflict ) ]


buildGame_on_conflict : Game_on_conflictRequiredFields -> (Game_on_conflictOptionalFields -> Game_on_conflictOptionalFields) -> Game_on_conflict
buildGame_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Game_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Game_on_conflictRequiredFields =
    { constraint : Outsixer.Enum.Game_constraint.Game_constraint
    , update_columns : List Outsixer.Enum.Game_update_column.Game_update_column
    }


type alias Game_on_conflictOptionalFields =
    { where_ : OptionalArgument Game_bool_exp }


{-| Type alias for the `Game_on_conflict` attributes. Note that this type
needs to use the `Game_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Game_on_conflictRaw =
    { constraint : Outsixer.Enum.Game_constraint.Game_constraint
    , update_columns : List Outsixer.Enum.Game_update_column.Game_update_column
    , where_ : OptionalArgument Game_bool_exp
    }


{-| Type for the Game\_on\_conflict input object.
-}
type Game_on_conflict
    = Game_on_conflict Game_on_conflictRaw


{-| Encode a Game\_on\_conflict into a value that can be used as an argument.
-}
encodeGame_on_conflict : Game_on_conflict -> Value
encodeGame_on_conflict (Game_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Outsixer.Enum.Game_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Outsixer.Enum.Game_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeGame_bool_exp |> Encode.optional input.where_ ) ]


buildGame_order_by : (Game_order_byOptionalFields -> Game_order_byOptionalFields) -> Game_order_by
buildGame_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { active = Absent, created_at = Absent, id = Absent, name = Absent, players_aggregate = Absent, updated_at = Absent, word = Absent }
    in
    { active = optionals.active, created_at = optionals.created_at, id = optionals.id, name = optionals.name, players_aggregate = optionals.players_aggregate, updated_at = optionals.updated_at, word = optionals.word }


type alias Game_order_byOptionalFields =
    { active : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , players_aggregate : OptionalArgument Player_aggregate_order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , word : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Game\_order\_by input object.
-}
type alias Game_order_by =
    { active : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , players_aggregate : OptionalArgument Player_aggregate_order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , word : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Game\_order\_by into a value that can be used as an argument.
-}
encodeGame_order_by : Game_order_by -> Value
encodeGame_order_by input =
    Encode.maybeObject
        [ ( "active", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.active ), ( "created_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.name ), ( "players_aggregate", encodePlayer_aggregate_order_by |> Encode.optional input.players_aggregate ), ( "updated_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.updated_at ), ( "word", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.word ) ]


buildGame_set_input : (Game_set_inputOptionalFields -> Game_set_inputOptionalFields) -> Game_set_input
buildGame_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { active = Absent, created_at = Absent, id = Absent, name = Absent, updated_at = Absent, word = Absent }
    in
    { active = optionals.active, created_at = optionals.created_at, id = optionals.id, name = optionals.name, updated_at = optionals.updated_at, word = optionals.word }


type alias Game_set_inputOptionalFields =
    { active : OptionalArgument Bool
    , created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , word : OptionalArgument String
    }


{-| Type for the Game\_set\_input input object.
-}
type alias Game_set_input =
    { active : OptionalArgument Bool
    , created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , word : OptionalArgument String
    }


{-| Encode a Game\_set\_input into a value that can be used as an argument.
-}
encodeGame_set_input : Game_set_input -> Value
encodeGame_set_input input =
    Encode.maybeObject
        [ ( "active", Encode.bool |> Encode.optional input.active ), ( "created_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created_at ), ( "id", Encode.int |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "updated_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.updated_at ), ( "word", Encode.string |> Encode.optional input.word ) ]


buildGame_stddev_order_by : (Game_stddev_order_byOptionalFields -> Game_stddev_order_byOptionalFields) -> Game_stddev_order_by
buildGame_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_stddev_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_stddev\_order\_by input object.
-}
type alias Game_stddev_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeGame_stddev_order_by : Game_stddev_order_by -> Value
encodeGame_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_stddev_pop_order_by : (Game_stddev_pop_order_byOptionalFields -> Game_stddev_pop_order_byOptionalFields) -> Game_stddev_pop_order_by
buildGame_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_stddev\_pop\_order\_by input object.
-}
type alias Game_stddev_pop_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeGame_stddev_pop_order_by : Game_stddev_pop_order_by -> Value
encodeGame_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_stddev_samp_order_by : (Game_stddev_samp_order_byOptionalFields -> Game_stddev_samp_order_byOptionalFields) -> Game_stddev_samp_order_by
buildGame_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_stddev\_samp\_order\_by input object.
-}
type alias Game_stddev_samp_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeGame_stddev_samp_order_by : Game_stddev_samp_order_by -> Value
encodeGame_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_sum_order_by : (Game_sum_order_byOptionalFields -> Game_sum_order_byOptionalFields) -> Game_sum_order_by
buildGame_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_sum_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_sum\_order\_by input object.
-}
type alias Game_sum_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_sum\_order\_by into a value that can be used as an argument.
-}
encodeGame_sum_order_by : Game_sum_order_by -> Value
encodeGame_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_var_pop_order_by : (Game_var_pop_order_byOptionalFields -> Game_var_pop_order_byOptionalFields) -> Game_var_pop_order_by
buildGame_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_var_pop_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_var\_pop\_order\_by input object.
-}
type alias Game_var_pop_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeGame_var_pop_order_by : Game_var_pop_order_by -> Value
encodeGame_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_var_samp_order_by : (Game_var_samp_order_byOptionalFields -> Game_var_samp_order_byOptionalFields) -> Game_var_samp_order_by
buildGame_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_var_samp_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_var\_samp\_order\_by input object.
-}
type alias Game_var_samp_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeGame_var_samp_order_by : Game_var_samp_order_by -> Value
encodeGame_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildGame_variance_order_by : (Game_variance_order_byOptionalFields -> Game_variance_order_byOptionalFields) -> Game_variance_order_by
buildGame_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Game_variance_order_byOptionalFields =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Type for the Game\_variance\_order\_by input object.
-}
type alias Game_variance_order_by =
    { id : OptionalArgument Outsixer.Enum.Order_by.Order_by }


{-| Encode a Game\_variance\_order\_by into a value that can be used as an argument.
-}
encodeGame_variance_order_by : Game_variance_order_by -> Value
encodeGame_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildInt_comparison_exp : (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields) -> Int_comparison_exp
buildInt_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input.eq_ ), ( "_gt", Encode.int |> Encode.optional input.gt_ ), ( "_gte", Encode.int |> Encode.optional input.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.int |> Encode.optional input.lt_ ), ( "_lte", Encode.int |> Encode.optional input.lte_ ), ( "_neq", Encode.int |> Encode.optional input.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input.nin_ ) ]


buildPlayer_aggregate_order_by : (Player_aggregate_order_byOptionalFields -> Player_aggregate_order_byOptionalFields) -> Player_aggregate_order_by
buildPlayer_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Player_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Player_avg_order_by
    , count : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , max : OptionalArgument Player_max_order_by
    , min : OptionalArgument Player_min_order_by
    , stddev : OptionalArgument Player_stddev_order_by
    , stddev_pop : OptionalArgument Player_stddev_pop_order_by
    , stddev_samp : OptionalArgument Player_stddev_samp_order_by
    , sum : OptionalArgument Player_sum_order_by
    , var_pop : OptionalArgument Player_var_pop_order_by
    , var_samp : OptionalArgument Player_var_samp_order_by
    , variance : OptionalArgument Player_variance_order_by
    }


{-| Type for the Player\_aggregate\_order\_by input object.
-}
type alias Player_aggregate_order_by =
    { avg : OptionalArgument Player_avg_order_by
    , count : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , max : OptionalArgument Player_max_order_by
    , min : OptionalArgument Player_min_order_by
    , stddev : OptionalArgument Player_stddev_order_by
    , stddev_pop : OptionalArgument Player_stddev_pop_order_by
    , stddev_samp : OptionalArgument Player_stddev_samp_order_by
    , sum : OptionalArgument Player_sum_order_by
    , var_pop : OptionalArgument Player_var_pop_order_by
    , var_samp : OptionalArgument Player_var_samp_order_by
    , variance : OptionalArgument Player_variance_order_by
    }


{-| Encode a Player\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodePlayer_aggregate_order_by : Player_aggregate_order_by -> Value
encodePlayer_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodePlayer_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodePlayer_max_order_by |> Encode.optional input.max ), ( "min", encodePlayer_min_order_by |> Encode.optional input.min ), ( "stddev", encodePlayer_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodePlayer_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodePlayer_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodePlayer_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodePlayer_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodePlayer_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodePlayer_variance_order_by |> Encode.optional input.variance ) ]


buildPlayer_arr_rel_insert_input : Player_arr_rel_insert_inputRequiredFields -> (Player_arr_rel_insert_inputOptionalFields -> Player_arr_rel_insert_inputOptionalFields) -> Player_arr_rel_insert_input
buildPlayer_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Player_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Player_arr_rel_insert_inputRequiredFields =
    { data : List Player_insert_input }


type alias Player_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Player_on_conflict }


{-| Type alias for the `Player_arr_rel_insert_input` attributes. Note that this type
needs to use the `Player_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Player_arr_rel_insert_inputRaw =
    { data : List Player_insert_input
    , on_conflict : OptionalArgument Player_on_conflict
    }


{-| Type for the Player\_arr\_rel\_insert\_input input object.
-}
type Player_arr_rel_insert_input
    = Player_arr_rel_insert_input Player_arr_rel_insert_inputRaw


{-| Encode a Player\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePlayer_arr_rel_insert_input : Player_arr_rel_insert_input -> Value
encodePlayer_arr_rel_insert_input (Player_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodePlayer_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodePlayer_on_conflict |> Encode.optional input.on_conflict ) ]


buildPlayer_avg_order_by : (Player_avg_order_byOptionalFields -> Player_avg_order_byOptionalFields) -> Player_avg_order_by
buildPlayer_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { game_id = Absent, id = Absent }
    in
    { game_id = optionals.game_id, id = optionals.id }


type alias Player_avg_order_byOptionalFields =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Player\_avg\_order\_by input object.
-}
type alias Player_avg_order_by =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Player\_avg\_order\_by into a value that can be used as an argument.
-}
encodePlayer_avg_order_by : Player_avg_order_by -> Value
encodePlayer_avg_order_by input =
    Encode.maybeObject
        [ ( "game_id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.game_id ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildPlayer_bool_exp : (Player_bool_expOptionalFields -> Player_bool_expOptionalFields) -> Player_bool_exp
buildPlayer_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, created_at = Absent, game = Absent, game_id = Absent, id = Absent, name = Absent, role = Absent, updated_at = Absent }
    in
    Player_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, created_at = optionals.created_at, game = optionals.game, game_id = optionals.game_id, id = optionals.id, name = optionals.name, role = optionals.role, updated_at = optionals.updated_at }


type alias Player_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Player_bool_exp))
    , not_ : OptionalArgument Player_bool_exp
    , or_ : OptionalArgument (List (Maybe Player_bool_exp))
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , game : OptionalArgument Game_bool_exp
    , game_id : OptionalArgument Int_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , role : OptionalArgument String_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Player_bool_exp` attributes. Note that this type
needs to use the `Player_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Player_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Player_bool_exp))
    , not_ : OptionalArgument Player_bool_exp
    , or_ : OptionalArgument (List (Maybe Player_bool_exp))
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , game : OptionalArgument Game_bool_exp
    , game_id : OptionalArgument Int_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , role : OptionalArgument String_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Player\_bool\_exp input object.
-}
type Player_bool_exp
    = Player_bool_exp Player_bool_expRaw


{-| Encode a Player\_bool\_exp into a value that can be used as an argument.
-}
encodePlayer_bool_exp : Player_bool_exp -> Value
encodePlayer_bool_exp (Player_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodePlayer_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodePlayer_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodePlayer_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input.created_at ), ( "game", encodeGame_bool_exp |> Encode.optional input.game ), ( "game_id", encodeInt_comparison_exp |> Encode.optional input.game_id ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "name", encodeString_comparison_exp |> Encode.optional input.name ), ( "role", encodeString_comparison_exp |> Encode.optional input.role ), ( "updated_at", encodeTimestamptz_comparison_exp |> Encode.optional input.updated_at ) ]


buildPlayer_inc_input : (Player_inc_inputOptionalFields -> Player_inc_inputOptionalFields) -> Player_inc_input
buildPlayer_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { game_id = Absent, id = Absent }
    in
    { game_id = optionals.game_id, id = optionals.id }


type alias Player_inc_inputOptionalFields =
    { game_id : OptionalArgument Int
    , id : OptionalArgument Int
    }


{-| Type for the Player\_inc\_input input object.
-}
type alias Player_inc_input =
    { game_id : OptionalArgument Int
    , id : OptionalArgument Int
    }


{-| Encode a Player\_inc\_input into a value that can be used as an argument.
-}
encodePlayer_inc_input : Player_inc_input -> Value
encodePlayer_inc_input input =
    Encode.maybeObject
        [ ( "game_id", Encode.int |> Encode.optional input.game_id ), ( "id", Encode.int |> Encode.optional input.id ) ]


buildPlayer_insert_input : (Player_insert_inputOptionalFields -> Player_insert_inputOptionalFields) -> Player_insert_input
buildPlayer_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, game = Absent, game_id = Absent, id = Absent, name = Absent, role = Absent, updated_at = Absent }
    in
    Player_insert_input { created_at = optionals.created_at, game = optionals.game, game_id = optionals.game_id, id = optionals.id, name = optionals.name, role = optionals.role, updated_at = optionals.updated_at }


type alias Player_insert_inputOptionalFields =
    { created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , game : OptionalArgument Game_obj_rel_insert_input
    , game_id : OptionalArgument Int
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , role : OptionalArgument String
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Player_insert_input` attributes. Note that this type
needs to use the `Player_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Player_insert_inputRaw =
    { created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , game : OptionalArgument Game_obj_rel_insert_input
    , game_id : OptionalArgument Int
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , role : OptionalArgument String
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    }


{-| Type for the Player\_insert\_input input object.
-}
type Player_insert_input
    = Player_insert_input Player_insert_inputRaw


{-| Encode a Player\_insert\_input into a value that can be used as an argument.
-}
encodePlayer_insert_input : Player_insert_input -> Value
encodePlayer_insert_input (Player_insert_input input) =
    Encode.maybeObject
        [ ( "created_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created_at ), ( "game", encodeGame_obj_rel_insert_input |> Encode.optional input.game ), ( "game_id", Encode.int |> Encode.optional input.game_id ), ( "id", Encode.int |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "role", Encode.string |> Encode.optional input.role ), ( "updated_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.updated_at ) ]


buildPlayer_max_order_by : (Player_max_order_byOptionalFields -> Player_max_order_byOptionalFields) -> Player_max_order_by
buildPlayer_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, game_id = Absent, id = Absent, name = Absent, role = Absent, updated_at = Absent }
    in
    { created_at = optionals.created_at, game_id = optionals.game_id, id = optionals.id, name = optionals.name, role = optionals.role, updated_at = optionals.updated_at }


type alias Player_max_order_byOptionalFields =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , role : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Player\_max\_order\_by input object.
-}
type alias Player_max_order_by =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , role : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Player\_max\_order\_by into a value that can be used as an argument.
-}
encodePlayer_max_order_by : Player_max_order_by -> Value
encodePlayer_max_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "game_id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.game_id ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.name ), ( "role", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.role ), ( "updated_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.updated_at ) ]


buildPlayer_min_order_by : (Player_min_order_byOptionalFields -> Player_min_order_byOptionalFields) -> Player_min_order_by
buildPlayer_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, game_id = Absent, id = Absent, name = Absent, role = Absent, updated_at = Absent }
    in
    { created_at = optionals.created_at, game_id = optionals.game_id, id = optionals.id, name = optionals.name, role = optionals.role, updated_at = optionals.updated_at }


type alias Player_min_order_byOptionalFields =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , role : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Player\_min\_order\_by input object.
-}
type alias Player_min_order_by =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , role : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Player\_min\_order\_by into a value that can be used as an argument.
-}
encodePlayer_min_order_by : Player_min_order_by -> Value
encodePlayer_min_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "game_id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.game_id ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.name ), ( "role", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.role ), ( "updated_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.updated_at ) ]


buildPlayer_obj_rel_insert_input : Player_obj_rel_insert_inputRequiredFields -> (Player_obj_rel_insert_inputOptionalFields -> Player_obj_rel_insert_inputOptionalFields) -> Player_obj_rel_insert_input
buildPlayer_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Player_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Player_obj_rel_insert_inputRequiredFields =
    { data : Player_insert_input }


type alias Player_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Player_on_conflict }


{-| Type alias for the `Player_obj_rel_insert_input` attributes. Note that this type
needs to use the `Player_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Player_obj_rel_insert_inputRaw =
    { data : Player_insert_input
    , on_conflict : OptionalArgument Player_on_conflict
    }


{-| Type for the Player\_obj\_rel\_insert\_input input object.
-}
type Player_obj_rel_insert_input
    = Player_obj_rel_insert_input Player_obj_rel_insert_inputRaw


{-| Encode a Player\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePlayer_obj_rel_insert_input : Player_obj_rel_insert_input -> Value
encodePlayer_obj_rel_insert_input (Player_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodePlayer_insert_input input.data |> Just ), ( "on_conflict", encodePlayer_on_conflict |> Encode.optional input.on_conflict ) ]


buildPlayer_on_conflict : Player_on_conflictRequiredFields -> (Player_on_conflictOptionalFields -> Player_on_conflictOptionalFields) -> Player_on_conflict
buildPlayer_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Player_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Player_on_conflictRequiredFields =
    { constraint : Outsixer.Enum.Player_constraint.Player_constraint
    , update_columns : List Outsixer.Enum.Player_update_column.Player_update_column
    }


type alias Player_on_conflictOptionalFields =
    { where_ : OptionalArgument Player_bool_exp }


{-| Type alias for the `Player_on_conflict` attributes. Note that this type
needs to use the `Player_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Player_on_conflictRaw =
    { constraint : Outsixer.Enum.Player_constraint.Player_constraint
    , update_columns : List Outsixer.Enum.Player_update_column.Player_update_column
    , where_ : OptionalArgument Player_bool_exp
    }


{-| Type for the Player\_on\_conflict input object.
-}
type Player_on_conflict
    = Player_on_conflict Player_on_conflictRaw


{-| Encode a Player\_on\_conflict into a value that can be used as an argument.
-}
encodePlayer_on_conflict : Player_on_conflict -> Value
encodePlayer_on_conflict (Player_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Outsixer.Enum.Player_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Outsixer.Enum.Player_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodePlayer_bool_exp |> Encode.optional input.where_ ) ]


buildPlayer_order_by : (Player_order_byOptionalFields -> Player_order_byOptionalFields) -> Player_order_by
buildPlayer_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, game = Absent, game_id = Absent, id = Absent, name = Absent, role = Absent, updated_at = Absent }
    in
    Player_order_by { created_at = optionals.created_at, game = optionals.game, game_id = optionals.game_id, id = optionals.id, name = optionals.name, role = optionals.role, updated_at = optionals.updated_at }


type alias Player_order_byOptionalFields =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , game : OptionalArgument Game_order_by
    , game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , role : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type alias for the `Player_order_by` attributes. Note that this type
needs to use the `Player_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Player_order_byRaw =
    { created_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , game : OptionalArgument Game_order_by
    , game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , name : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , role : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Player\_order\_by input object.
-}
type Player_order_by
    = Player_order_by Player_order_byRaw


{-| Encode a Player\_order\_by into a value that can be used as an argument.
-}
encodePlayer_order_by : Player_order_by -> Value
encodePlayer_order_by (Player_order_by input) =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "game", encodeGame_order_by |> Encode.optional input.game ), ( "game_id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.game_id ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.name ), ( "role", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.role ), ( "updated_at", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.updated_at ) ]


buildPlayer_set_input : (Player_set_inputOptionalFields -> Player_set_inputOptionalFields) -> Player_set_input
buildPlayer_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, game_id = Absent, id = Absent, name = Absent, role = Absent, updated_at = Absent }
    in
    { created_at = optionals.created_at, game_id = optionals.game_id, id = optionals.id, name = optionals.name, role = optionals.role, updated_at = optionals.updated_at }


type alias Player_set_inputOptionalFields =
    { created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , game_id : OptionalArgument Int
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , role : OptionalArgument String
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    }


{-| Type for the Player\_set\_input input object.
-}
type alias Player_set_input =
    { created_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , game_id : OptionalArgument Int
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , role : OptionalArgument String
    , updated_at : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    }


{-| Encode a Player\_set\_input into a value that can be used as an argument.
-}
encodePlayer_set_input : Player_set_input -> Value
encodePlayer_set_input input =
    Encode.maybeObject
        [ ( "created_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created_at ), ( "game_id", Encode.int |> Encode.optional input.game_id ), ( "id", Encode.int |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "role", Encode.string |> Encode.optional input.role ), ( "updated_at", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.updated_at ) ]


buildPlayer_stddev_order_by : (Player_stddev_order_byOptionalFields -> Player_stddev_order_byOptionalFields) -> Player_stddev_order_by
buildPlayer_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { game_id = Absent, id = Absent }
    in
    { game_id = optionals.game_id, id = optionals.id }


type alias Player_stddev_order_byOptionalFields =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Player\_stddev\_order\_by input object.
-}
type alias Player_stddev_order_by =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Player\_stddev\_order\_by into a value that can be used as an argument.
-}
encodePlayer_stddev_order_by : Player_stddev_order_by -> Value
encodePlayer_stddev_order_by input =
    Encode.maybeObject
        [ ( "game_id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.game_id ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildPlayer_stddev_pop_order_by : (Player_stddev_pop_order_byOptionalFields -> Player_stddev_pop_order_byOptionalFields) -> Player_stddev_pop_order_by
buildPlayer_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { game_id = Absent, id = Absent }
    in
    { game_id = optionals.game_id, id = optionals.id }


type alias Player_stddev_pop_order_byOptionalFields =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Player\_stddev\_pop\_order\_by input object.
-}
type alias Player_stddev_pop_order_by =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Player\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodePlayer_stddev_pop_order_by : Player_stddev_pop_order_by -> Value
encodePlayer_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "game_id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.game_id ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildPlayer_stddev_samp_order_by : (Player_stddev_samp_order_byOptionalFields -> Player_stddev_samp_order_byOptionalFields) -> Player_stddev_samp_order_by
buildPlayer_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { game_id = Absent, id = Absent }
    in
    { game_id = optionals.game_id, id = optionals.id }


type alias Player_stddev_samp_order_byOptionalFields =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Player\_stddev\_samp\_order\_by input object.
-}
type alias Player_stddev_samp_order_by =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Player\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodePlayer_stddev_samp_order_by : Player_stddev_samp_order_by -> Value
encodePlayer_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "game_id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.game_id ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildPlayer_sum_order_by : (Player_sum_order_byOptionalFields -> Player_sum_order_byOptionalFields) -> Player_sum_order_by
buildPlayer_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { game_id = Absent, id = Absent }
    in
    { game_id = optionals.game_id, id = optionals.id }


type alias Player_sum_order_byOptionalFields =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Player\_sum\_order\_by input object.
-}
type alias Player_sum_order_by =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Player\_sum\_order\_by into a value that can be used as an argument.
-}
encodePlayer_sum_order_by : Player_sum_order_by -> Value
encodePlayer_sum_order_by input =
    Encode.maybeObject
        [ ( "game_id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.game_id ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildPlayer_var_pop_order_by : (Player_var_pop_order_byOptionalFields -> Player_var_pop_order_byOptionalFields) -> Player_var_pop_order_by
buildPlayer_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { game_id = Absent, id = Absent }
    in
    { game_id = optionals.game_id, id = optionals.id }


type alias Player_var_pop_order_byOptionalFields =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Player\_var\_pop\_order\_by input object.
-}
type alias Player_var_pop_order_by =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Player\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodePlayer_var_pop_order_by : Player_var_pop_order_by -> Value
encodePlayer_var_pop_order_by input =
    Encode.maybeObject
        [ ( "game_id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.game_id ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildPlayer_var_samp_order_by : (Player_var_samp_order_byOptionalFields -> Player_var_samp_order_byOptionalFields) -> Player_var_samp_order_by
buildPlayer_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { game_id = Absent, id = Absent }
    in
    { game_id = optionals.game_id, id = optionals.id }


type alias Player_var_samp_order_byOptionalFields =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Player\_var\_samp\_order\_by input object.
-}
type alias Player_var_samp_order_by =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Player\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodePlayer_var_samp_order_by : Player_var_samp_order_by -> Value
encodePlayer_var_samp_order_by input =
    Encode.maybeObject
        [ ( "game_id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.game_id ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildPlayer_variance_order_by : (Player_variance_order_byOptionalFields -> Player_variance_order_byOptionalFields) -> Player_variance_order_by
buildPlayer_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { game_id = Absent, id = Absent }
    in
    { game_id = optionals.game_id, id = optionals.id }


type alias Player_variance_order_byOptionalFields =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Type for the Player\_variance\_order\_by input object.
-}
type alias Player_variance_order_by =
    { game_id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    , id : OptionalArgument Outsixer.Enum.Order_by.Order_by
    }


{-| Encode a Player\_variance\_order\_by into a value that can be used as an argument.
-}
encodePlayer_variance_order_by : Player_variance_order_by -> Value
encodePlayer_variance_order_by input =
    Encode.maybeObject
        [ ( "game_id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.game_id ), ( "id", Encode.enum Outsixer.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildString_comparison_exp : (String_comparison_expOptionalFields -> String_comparison_expOptionalFields) -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTimestamptz_comparison_exp : (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields) -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Outsixer.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Outsixer.ScalarCodecs.Timestamptz)
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Outsixer.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Outsixer.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Outsixer.ScalarCodecs.Timestamptz)
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.eq_ ), ( "_gt", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gt_ ), ( "_gte", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gte_ ), ( "_in", ((Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lt_ ), ( "_lte", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lte_ ), ( "_neq", (Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.neq_ ), ( "_nin", ((Outsixer.ScalarCodecs.codecs |> Outsixer.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.nin_ ) ]
